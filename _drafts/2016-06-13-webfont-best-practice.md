---
title: '웹 폰트를 로컬 스토리지에 저장해서 안정성 높이기'
layout: post
tags:
  - tip
  - webfont
---

요샌 웹 폰트를 사용할 만한 것 같다. 그러던 차 최근 프로젝트에서 웹 폰트를 사용해서, 오래 전에 눈여겨 봤던 [스매싱 매거진의 웹 폰트 적용 방식](https://www.smashingmagazine.com/2014/09/improving-smashing-magazine-performance-case-study/#webfonts)을 사용해 보기로 했다.[^fn2] 정확히 말하면 스매싱 매거진이 [가디언의 선례](https://github.com/ahume/webfontjson)를 따라 적용한 방식이다.

여기서는 웹 폰트 최적화에 대해서만 다루는데, 스매싱 매거진의 흥미진진한 이야기를 요약하면 이렇다.

- 보이는 모양은 중요하기 때문에 모바일에서 웹 폰트를 사용하지 않게 하는 것은 고려사항이 아니었다.
- 웹 폰트가 6개(글꼴 두 개 각각의 레귤러, 이탤릭, 볼드)로 300KB나 됐다.
- 잦은 FOUT[^fn1] 현상을 피하기 위해 웹 폰트는 `<head>`에서 불러와야 한다.
- 그러나 HTTP 캐시는 매우 불안정했다. 때때로 다시 다운로드하더라. 이것이 야기하는 가장 큰 문제는, [폰트를 다 다운로드할 때까지 글자가 보이지 않게 된다](http://ianfeather.co.uk/web-fonts-and-the-critical-path/)는 것이다. 심지어 웹폰트 제공 서버에 문제가 생기면 아예 다운로드가 안 되고, 글자는 전혀 나타나지 않았다. [즉, 텅 비어 있었다. - 역자]
- 글자 공백 현상을 막기 위해, ajax로 글꼴을 로딩하는 타입킷과 구글 웹 폰트 로더를 사용해 봤는데, FOUT 현상이 너무 자주 일어나 읽기 경험을 파괴하는 수준이었다. 역시나 HTTP 캐시는 매우 불안정했다. 다만, 웹 폰트를 모두 다운로드하기 전까지 표시되도록 지정했던 대체 글꼴 목록(iOS, 안드로이드, 윈도우폰...)은 여전히 사용하고 있다.
- 미디어쿼리를 사용해서 데스크톱에서만 웹 폰트를 다운로드하게 해 봤다. 모바일 성능은 확실히 개선됐지만, 만족스럽지 않았다. 우리 정체성을 생각할 때 옳은 방법이 아니라고 느꼈다. 그래서 다시 포기.
- 남은 방법은 캐시를 개선하는 것밖에 없었다. `localStorage`를 사용하거나, `AppCache`를 사용하거나. 제이크 아치발드(Jake Archibald)가 [앱 캐시의 복잡성](http://alistapart.com/article/application-cache-is-a-douchebag)에 대해 쓴 훌륭한 글을 보고 나서 로컬 스토리지를 사용하기로 결정했다.
- 로컬 스토리지는 도메인당 5메가 정도로 용량 제한이 있다. 그래서 스매싱 매거진 도메인으로 저장할 수 있도록 허락해 달라고 폰트덱에 요청했는데, 폰트덱에서 흔쾌히 허락해 줬다.
- 로컬 스토리지에 폰트를 캐시했다가 꺼내 쓰는 것은, 브라우저의 캐시를 꺼내 쓰는 것보다 꽤 느린데, 대신 훨씬 안정적이었다. 완벽한 해법은 아니지만 성능을 비약적으로 올렸다.
- 브라우저가 로컬 스토리지를 지원하지 않는다면, 그 땐 woff 폰트를 내장한 CSS 파일의 링크를 제공하고 솔직히 운에 맡겼다. [woff 파일 포맷을 지원하지 않는 브라우저](http://caniuse.com/#search=woff)(IE8, Opera Mini, Android <= 4.3)에 대해서는 폰트덱의 외부 URL을 제공한다.
- `<head>` 쪽에 짧은 자바스크립트 코드를 둬서, FOUT를 방지했다. 쿠키를 체크해서 로컬 스토리지 글꼴 저장 여부를 알아낸다. 저장하지 않았다면 우선 페이지를 렌더링한 뒤, base64로 woff 글꼴을 엠베드한 CSS 파일 내용을 ajax로 가져와 `<head>`에 뿌리고, 그걸 로컬 스토리지에 저장한다. FOUT는 이 때 한 번 일어난다(관련 코드는 스매싱 매거진 페이지와 [gist](https://gist.github.com/hdragomir/8f00ce2581795fd7b1b7)에서 볼 수 있다). 이후 방문 페이지에서는 `localStorage`에 저장된 CSS 내용을 꺼내서 `<head>`에 박기 때문에 FOUT가 일어나지 않는다.
- 물론 첫 번째 방문 때는 로컬 스토리지에 저장만 하고 웹 폰트로 전환하지 않도록 해서 아예 FOUT를 방지할 수도 있었다. 하지만, 타이포그라피는 우리 정체성에서 중요하다. 한 번 정도 전환이 일어나는 것은 받아들일 만했다.
- 테스트하며 알게 된 황당한 문제들. 웹뷰의 캐시는 영속적이지 않아서, 트윗덱과 페이스북에서는 글꼴을 계속 비동기적으로 다운로드했다. 구형 블랙베리는 배터리가 완전 방전되면 쿠키와 캐시를 모두 날리는 것으로 보인다. 설정에 따라서는 모바일 사파리에서도 글꼴이 영속적이지 않는 경우가 있었다.
- **결과**: 첫 페이지 방문에서 700ms를 절약했다. 로컬 스토리지를 이용한 이어지는 방문에선 웹 폰트 적용에 40~50ms밖에 걸리지 않았다. 우리 웹사이트 개선에서 가장 중요했던 게 뭐냐고 묻는다면 단연 웹 폰트 개선이라고 할 수 있다.
- [woff2는 브라우저 지원이 충분치 않아서](http://caniuse.com/#search=woff2) 아직 고려하지 않고 있다. [2016년 6월 14일 현재 크롬, 파이어폭스, 오페라, 안드로이드 브라우저, 안드로이드 크롬만 지원하고 있다. IE11, 엣지, 사파리, 모바일 사파리, 오페라 미니는 지원하지 않는다. - 역자]

그럼 이제 실제 적용에 대해 이야기해 보자!

[^fn1]: FOUT는 "기본 글꼴 깜빡임(flash of unstyled text)"의 약어다. 웹 폰트를 아직 다 다운로드하기 전에, 기본 글꼴로 콘텐츠가 표시됐다가 웹 폰트를 다 다운로드하면 웹 폰트로 전환되면서 내용이 한 번 깜빡이는 현상을 말한다. 2009년에 폴 아이리쉬(Paul Irish)가 이 이름을 붙였다([Fighting the @font-face FOUT](http://www.paulirish.com/2009/fighting-the-font-face-fout/)). 이후 각양 각색의 해결책은 CSS-TRICKS의 [FOUT, FOIT, FOFT](https://css-tricks.com/fout-foit-foft/) 에 잘 나와 있다.  
현재는 모든 주요 브라우저가 FOIT로 불리는 해결책을 적용한 상태다. FOIT란 "텅 비어있다가 나타남(Flash of Invisible Text)" 방식이다. 이 방식은, 웹 폰트를 전부 다운로드하기 전까지는 글자를 아예 표시하지 않다가 다운로드가 끝나면 표시하는 방법인데, 개인적으론 FOUT보다 더 짜증난다. 한국어 웹 폰트는 용량이 커서, 다운로드 속도가 느리면 아주 오랫동안 화면이 비어 있게 된다.  
스매싱 매거진이 사용한 방법은 페이지를 처음 불러올 때 FOUT를 한 번 허용하고(즉, 기본 글꼴로 콘텐츠를 읽을 수 있게 놔두다가 한 번 깜빡 하면서 웹 폰트로 전환하고), 그 뒤 웹 폰트를 `localStorage`에 저장해서 이어지는 페이지부터는 안정적으로 FOUT 현상을 회피하는 방법이다. 위 CSS-TRICKS의 글에서 맨 아래 소개돼 있다.

[^fn2]: 내가 인용한 링크를 클릭하면 사실 '웹 폰트 지연(Deferring Web Fonts)' 항목으로 이동하게 되는데, '사실 웹 폰트 지연' 파트 외에도 글 전체가 다 좋다. 맨 앞부터 읽어 보는 것도 추천한다. 2014년 9월에 씌어져 그리 오래 된 글도 아니고, 여러 모로 웹사이트 최적화에 대한 통찰을 준다.
